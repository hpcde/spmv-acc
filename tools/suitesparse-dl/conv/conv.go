package conv

import (
	"encoding/binary"
	"encoding/csv"
	"errors"
	"flag"
	"github.com/genshen/cmds"
	"io"
	"log"
	"os"
	"path/filepath"
)

var convCommand = &cmds.Command{
	Name:    "conv",
	Summary: "conv matrix market format to csr binary format",
	Description: `conv matrix market format to csr binary format:
In single conversion mode, it convert one .mtx file (path is specified by -mm) to bin file (path is specified by -o);
In batched conversion mode, it can convert multiple .mtx files to bin files. flag -mm specifics a csv file (the csv file can be generated by "suitesparse-dl list",
the csv file specifics file name and file path of each .mtx file). flag -o specifics path for converted bin files`,
	CustomFlags: false,
	HasOptions:  true,
}

func init() {
	c := Conv{}
	convCommand.Runner = &c
	fs := flag.NewFlagSet("conv", flag.ContinueOnError)
	convCommand.FlagSet = fs
	convCommand.FlagSet.StringVar(&(c.input), "mm", "", `matrix market path or a csv file path for batched conversion mode.`)
	convCommand.FlagSet.StringVar(&(c.output), "o", "", `filepath of binary output.`)
	convCommand.FlagSet.BoolVar(&(c.litterEndian), "l", true, `byte order (litterEndian or BigEndian).`)
	convCommand.FlagSet.BoolVar(&(c.batched), "b", false, `if true, use batched mode, which read multiple .mtx files and convert them to binary file.`)
	convCommand.FlagSet.Usage = convCommand.Usage // use default usage provided by cmds.Command.
	cmds.AllCommands = append(cmds.AllCommands, convCommand)
}

type Conv struct {
	input        string
	output       string
	litterEndian bool
	batched      bool
}

func (c *Conv) PreRun() error {
	if c.output == "" {
		c.output = c.input + ".bin"
	}
	return nil
}

func (c *Conv) Run() error {
	if !c.batched {
		return ConvertOneMtx(c.input, c.output, c.litterEndian)
	}
	return batchedConvert(c.input, c.output, c.litterEndian)
}

func batchedConvert(input string, output string, litterEndian bool) error {
	if file, err := os.Open(input); err != nil {
		return err
	} else {
		defer file.Close()

		reader := csv.NewReader(file)
		records, err := reader.ReadAll()
		if err != nil {
			return err
		}
		for _, row := range records {
			if len(row) != 2 {
				return errors.New("invalid row length")
			}
			mtxName := row[0]
			mtxPath := row[1]
			// use c.output as parent dir and change file ext to .bin2
			binFilepath := filepath.Join(output, mtxName+".bin2")
			log.Printf("Converting mtx file %s to bin file %s.\n", mtxPath, binFilepath)
			if err := ConvertOneMtx(mtxPath, binFilepath, litterEndian); err != nil {
				return err
			}
		}
	}
	return nil
}

func ConvertOneMtx(inp string, output string, litterEndian bool) error {
	mm, err := conv(inp)
	if err != nil {
		return err
	}
	// to CSR
	mm.Sort()
	rowPtr := make([]TpIndex, mm.header.numRows+1)
	colIndex := make([]TpIndex, len(mm.data))
	nonZeros := make([]TpFloat, len(mm.data))
	for i, ele := range mm.data {
		if ele.row >= mm.header.numRows {
			return errors.New("out of range when converting to CSR")
		}
		colIndex[i] = ele.col
		nonZeros[i] = ele.value
		rowPtr[ele.row+1]++
	}
	var i TpIndex = 0
	for ; i < mm.header.numRows; i++ {
		nnzThisRow := rowPtr[i+1]
		rowPtr[i+1] = rowPtr[i] + nnzThisRow
	}

	// write binary
	if outfile, err := os.Create(output); err != nil {
		return err
	} else {
		var byteOrder binary.ByteOrder = binary.LittleEndian
		if !litterEndian {
			byteOrder = binary.BigEndian
		}

		// write binary header to the binary file
		if err := writeBinHeader(outfile, byteOrder, mm.header.val_type); err != nil {
			return err
		}

		// write CSR matrix
		var nnz TpIndex = (TpIndex)(len(mm.data))
		if err := binary.Write(outfile, byteOrder, &(mm.header.numRows)); err != nil {
			return err
		}
		if err := binary.Write(outfile, byteOrder, &(mm.header.numColumns)); err != nil {
			return err
		}
		if err := binary.Write(outfile, byteOrder, &(nnz)); err != nil {
			return err
		}
		if err := binary.Write(outfile, byteOrder, rowPtr); err != nil {
			return err
		}
		if err := binary.Write(outfile, byteOrder, colIndex); err != nil {
			return err
		}
		// write CSR matrix: the value part
		err := writeCsrMatrixValues(outfile, byteOrder, mm.header.val_type, nonZeros)
		if err != nil {
			return err
		}
	}
	return nil
}

func writeBinHeader(outfile io.Writer, byteOrder binary.ByteOrder, valTp MMValueType) error {
	// write magic number
	var magicNumber int32 = 0x20211015
	if err := binary.Write(outfile, byteOrder, &(magicNumber)); err != nil {
		return err
	}
	// write format version
	var formatVersion int32 = 0x2
	if err := binary.Write(outfile, byteOrder, &(formatVersion)); err != nil {
		return err
	}
	// write value type
	if err := binary.Write(outfile, byteOrder, &(valTp)); err != nil {
		return err
	}
	return nil
}

func writeCsrMatrixValues(outfile io.Writer, byteOrder binary.ByteOrder, valTp MMValueType, nonZeros []TpFloat) error {
	if valTp == MMValueTypeUnknown {
		return errors.New("unknown value type in mm file")
	}
	if valTp == MMValueTypePattern {
		return nil
	}

	if valTp == MMValueTypeInt {
		nonZerosInt := make([]TpValInt32, len(nonZeros))
		for i, zs := range nonZeros {
			nonZerosInt[i] = TpValInt32(zs)
		}
		if err := binary.Write(outfile, byteOrder, nonZerosInt); err != nil {
			return err
		}
		return nil
	} else {
		if err := binary.Write(outfile, byteOrder, nonZeros); err != nil {
			return err
		}
		return nil
	}
}
